/*
            foreach(Node baby in node.getNodeChildren())
            {
                el_counter++;
                int x = currentX;
                x += (i - child_offset);
                int y = currentY + 2;
                DrawElement el = new DrawElement(baby, oddsize(baby.value_splitter) , oddsize(baby.label) , x, y);
                
                // Since we know this baby will be added to the queue later on and will be iterated upon
                // we do not need to add its width to the offset now.
                node_babies.Add(el);

                i++;
            }
            foreach(Leaf baby in node.getLeafChildren())
            {
                el_counter++;
                int x = currentX;
                x += (i - child_offset);
                int y = currentY + 2;
                DrawElement el = new DrawElement(null, oddsize(baby.value_splitter), oddsize(baby.classifier), x, y);
                
                // This leaf directly adds to its parents width usage, so we will calculate how much and add it to side offset. 
                child_width += added_width(oddsize(baby.value_splitter), oddsize(baby.classifier));
                leaf_babies.Add(el);

                i++;
            }
            */
            /*
            // Total space occupied by the just handled node is side_offset
            // Babies are made, lets now move up existing drawelements.
            Console.WriteLine($"[Post-Birth] : Move elements with {child_width}");

            move_other_elements(ref all_elements, currentX, child_width);
            // Add the babies to the all elements
            all_elements.AddRange(babies);
            
            outputImage(generate_image_from_elements(all_elements));
            */